// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: results.sql

package sqlc

import (
	"context"
	"database/sql"
	"time"
)

const countResultsByRunID = `-- name: CountResultsByRunID :one
SELECT COUNT(*) as count
FROM ts.results_raw
WHERE run_id = $1
`

func (q *Queries) CountResultsByRunID(ctx context.Context, runID string) (int64, error) {
	row := q.db.QueryRowContext(ctx, countResultsByRunID, runID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const getAggregatedMetrics = `-- name: GetAggregatedMetrics :many
SELECT monitor_id, region, bucket, count, error_count, error_rate, p50_ms, p95_ms, p99_ms, min_ms, max_ms, avg_ms FROM ts.results_agg_1m
WHERE monitor_id = $1
AND bucket >= $2
AND bucket <= $3
ORDER BY bucket DESC
`

type GetAggregatedMetricsParams struct {
	MonitorID string      `json:"monitor_id"`
	Bucket    interface{} `json:"bucket"`
	Bucket_2  interface{} `json:"bucket_2"`
}

func (q *Queries) GetAggregatedMetrics(ctx context.Context, arg *GetAggregatedMetricsParams) ([]*TsResultsAgg1m, error) {
	rows, err := q.db.QueryContext(ctx, getAggregatedMetrics, arg.MonitorID, arg.Bucket, arg.Bucket_2)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*TsResultsAgg1m
	for rows.Next() {
		var i TsResultsAgg1m
		if err := rows.Scan(
			&i.MonitorID,
			&i.Region,
			&i.Bucket,
			&i.Count,
			&i.ErrorCount,
			&i.ErrorRate,
			&i.P50Ms,
			&i.P95Ms,
			&i.P99Ms,
			&i.MinMs,
			&i.MaxMs,
			&i.AvgMs,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getLatestResultPerMonitor = `-- name: GetLatestResultPerMonitor :many
SELECT DISTINCT ON (monitor_id) 
    monitor_id, region, event_at, status, http_code, total_ms
FROM ts.results_raw
WHERE event_at >= NOW() - INTERVAL '5 minutes'
ORDER BY monitor_id, event_at DESC
`

type GetLatestResultPerMonitorRow struct {
	MonitorID string        `json:"monitor_id"`
	Region    string        `json:"region"`
	EventAt   time.Time     `json:"event_at"`
	Status    string        `json:"status"`
	HttpCode  sql.NullInt32 `json:"http_code"`
	TotalMs   sql.NullInt32 `json:"total_ms"`
}

func (q *Queries) GetLatestResultPerMonitor(ctx context.Context) ([]*GetLatestResultPerMonitorRow, error) {
	rows, err := q.db.QueryContext(ctx, getLatestResultPerMonitor)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*GetLatestResultPerMonitorRow
	for rows.Next() {
		var i GetLatestResultPerMonitorRow
		if err := rows.Scan(
			&i.MonitorID,
			&i.Region,
			&i.EventAt,
			&i.Status,
			&i.HttpCode,
			&i.TotalMs,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getRecentResults = `-- name: GetRecentResults :many
SELECT run_id, monitor_id, region, event_at, status, http_code, dns_ms, connect_ms, tls_ms, ttfb_ms, download_ms, total_ms, size_bytes, error_message FROM ts.results_raw
WHERE monitor_id = $1
AND event_at >= NOW() - INTERVAL '1 hour'
ORDER BY event_at DESC
LIMIT $2
`

type GetRecentResultsParams struct {
	MonitorID string `json:"monitor_id"`
	Limit     int32  `json:"limit"`
}

func (q *Queries) GetRecentResults(ctx context.Context, arg *GetRecentResultsParams) ([]*TsResultsRaw, error) {
	rows, err := q.db.QueryContext(ctx, getRecentResults, arg.MonitorID, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*TsResultsRaw
	for rows.Next() {
		var i TsResultsRaw
		if err := rows.Scan(
			&i.RunID,
			&i.MonitorID,
			&i.Region,
			&i.EventAt,
			&i.Status,
			&i.HttpCode,
			&i.DnsMs,
			&i.ConnectMs,
			&i.TlsMs,
			&i.TtfbMs,
			&i.DownloadMs,
			&i.TotalMs,
			&i.SizeBytes,
			&i.ErrorMessage,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getResultByRunIDAndTime = `-- name: GetResultByRunIDAndTime :one
SELECT status, http_code, total_ms
FROM ts.results_raw
WHERE run_id = $1
AND event_at = $2
`

type GetResultByRunIDAndTimeParams struct {
	RunID   string    `json:"run_id"`
	EventAt time.Time `json:"event_at"`
}

type GetResultByRunIDAndTimeRow struct {
	Status   string        `json:"status"`
	HttpCode sql.NullInt32 `json:"http_code"`
	TotalMs  sql.NullInt32 `json:"total_ms"`
}

func (q *Queries) GetResultByRunIDAndTime(ctx context.Context, arg *GetResultByRunIDAndTimeParams) (*GetResultByRunIDAndTimeRow, error) {
	row := q.db.QueryRowContext(ctx, getResultByRunIDAndTime, arg.RunID, arg.EventAt)
	var i GetResultByRunIDAndTimeRow
	err := row.Scan(&i.Status, &i.HttpCode, &i.TotalMs)
	return &i, err
}

const getUptimeData24h = `-- name: GetUptimeData24h :one
SELECT 
    COALESCE(CAST(SUM(total_checks) AS BIGINT), 0) as total_checks,
    COALESCE(CAST(SUM(successful_checks) AS BIGINT), 0) as successful_checks,
    COALESCE(CAST(SUM(failed_checks) AS BIGINT), 0) as failed_checks,
    COALESCE(CAST(SUM(successful_checks) AS FLOAT) / NULLIF(SUM(total_checks), 0) * 100, 0)::int as uptime_percentage
FROM ts.results_agg_1h
WHERE monitor_id = $1
AND bucket >= NOW() - INTERVAL '24 hours'
`

type GetUptimeData24hRow struct {
	TotalChecks      interface{} `json:"total_checks"`
	SuccessfulChecks interface{} `json:"successful_checks"`
	FailedChecks     interface{} `json:"failed_checks"`
	UptimePercentage int32       `json:"uptime_percentage"`
}

func (q *Queries) GetUptimeData24h(ctx context.Context, monitorID string) (*GetUptimeData24hRow, error) {
	row := q.db.QueryRowContext(ctx, getUptimeData24h, monitorID)
	var i GetUptimeData24hRow
	err := row.Scan(
		&i.TotalChecks,
		&i.SuccessfulChecks,
		&i.FailedChecks,
		&i.UptimePercentage,
	)
	return &i, err
}

const getUptimeData24hRaw = `-- name: GetUptimeData24hRaw :one
SELECT 
    COALESCE(COUNT(*), 0) as total_checks,
    COALESCE(COUNT(*) FILTER (WHERE status = 'OK'), 0) as successful_checks,
    COALESCE(COUNT(*) FILTER (WHERE status != 'OK'), 0) as failed_checks,
    COALESCE(CAST(COUNT(*) FILTER (WHERE status = 'OK') AS FLOAT) / NULLIF(COUNT(*), 0) * 100, 0)::int as uptime_percentage
FROM ts.results_raw
WHERE monitor_id = $1
AND event_at >= NOW() - INTERVAL '24 hours'
`

type GetUptimeData24hRawRow struct {
	TotalChecks      interface{} `json:"total_checks"`
	SuccessfulChecks interface{} `json:"successful_checks"`
	FailedChecks     interface{} `json:"failed_checks"`
	UptimePercentage int32       `json:"uptime_percentage"`
}

func (q *Queries) GetUptimeData24hRaw(ctx context.Context, monitorID string) (*GetUptimeData24hRawRow, error) {
	row := q.db.QueryRowContext(ctx, getUptimeData24hRaw, monitorID)
	var i GetUptimeData24hRawRow
	err := row.Scan(
		&i.TotalChecks,
		&i.SuccessfulChecks,
		&i.FailedChecks,
		&i.UptimePercentage,
	)
	return &i, err
}

const getUptimeData30d = `-- name: GetUptimeData30d :one
SELECT 
    COALESCE(CAST(SUM(total_checks) AS BIGINT), 0) as total_checks,
    COALESCE(CAST(SUM(successful_checks) AS BIGINT), 0) as successful_checks,
    COALESCE(CAST(SUM(failed_checks) AS BIGINT), 0) as failed_checks,
    COALESCE(CAST(SUM(successful_checks) AS FLOAT) / NULLIF(SUM(total_checks), 0) * 100, 0)::int as uptime_percentage
FROM ts.results_agg_1d
WHERE monitor_id = $1
AND bucket >= NOW() - INTERVAL '30 days'
`

type GetUptimeData30dRow struct {
	TotalChecks      interface{} `json:"total_checks"`
	SuccessfulChecks interface{} `json:"successful_checks"`
	FailedChecks     interface{} `json:"failed_checks"`
	UptimePercentage int32       `json:"uptime_percentage"`
}

func (q *Queries) GetUptimeData30d(ctx context.Context, monitorID string) (*GetUptimeData30dRow, error) {
	row := q.db.QueryRowContext(ctx, getUptimeData30d, monitorID)
	var i GetUptimeData30dRow
	err := row.Scan(
		&i.TotalChecks,
		&i.SuccessfulChecks,
		&i.FailedChecks,
		&i.UptimePercentage,
	)
	return &i, err
}

const getUptimeData7d = `-- name: GetUptimeData7d :one
SELECT 
    COALESCE(CAST(SUM(total_checks) AS BIGINT), 0) as total_checks,
    COALESCE(CAST(SUM(successful_checks) AS BIGINT), 0) as successful_checks,
    COALESCE(CAST(SUM(failed_checks) AS BIGINT), 0) as failed_checks,
    COALESCE(CAST(SUM(successful_checks) AS FLOAT) / NULLIF(SUM(total_checks), 0) * 100, 0)::int as uptime_percentage
FROM ts.results_agg_1h
WHERE monitor_id = $1
AND bucket >= NOW() - INTERVAL '7 days'
`

type GetUptimeData7dRow struct {
	TotalChecks      interface{} `json:"total_checks"`
	SuccessfulChecks interface{} `json:"successful_checks"`
	FailedChecks     interface{} `json:"failed_checks"`
	UptimePercentage int32       `json:"uptime_percentage"`
}

func (q *Queries) GetUptimeData7d(ctx context.Context, monitorID string) (*GetUptimeData7dRow, error) {
	row := q.db.QueryRowContext(ctx, getUptimeData7d, monitorID)
	var i GetUptimeData7dRow
	err := row.Scan(
		&i.TotalChecks,
		&i.SuccessfulChecks,
		&i.FailedChecks,
		&i.UptimePercentage,
	)
	return &i, err
}

const getUptimeTimeline24h = `-- name: GetUptimeTimeline24h :many
SELECT 
    time_bucket(INTERVAL '15 minutes', event_at) AS bucket,
    COUNT(*) as total_checks,
    COUNT(*) FILTER (WHERE status = 'OK') as successful_checks,
    COALESCE(CAST(COUNT(*) FILTER (WHERE status = 'OK') AS FLOAT) / NULLIF(COUNT(*), 0) * 100, 0)::int as uptime_percentage
FROM ts.results_raw
WHERE monitor_id = $1
AND event_at >= NOW() - INTERVAL '24 hours'
GROUP BY bucket
ORDER BY bucket ASC
`

type GetUptimeTimeline24hRow struct {
	Bucket           interface{} `json:"bucket"`
	TotalChecks      int64       `json:"total_checks"`
	SuccessfulChecks int64       `json:"successful_checks"`
	UptimePercentage int32       `json:"uptime_percentage"`
}

func (q *Queries) GetUptimeTimeline24h(ctx context.Context, monitorID string) ([]*GetUptimeTimeline24hRow, error) {
	rows, err := q.db.QueryContext(ctx, getUptimeTimeline24h, monitorID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*GetUptimeTimeline24hRow
	for rows.Next() {
		var i GetUptimeTimeline24hRow
		if err := rows.Scan(
			&i.Bucket,
			&i.TotalChecks,
			&i.SuccessfulChecks,
			&i.UptimePercentage,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUptimeTimeline30d = `-- name: GetUptimeTimeline30d :many
SELECT
    bucket,
    total_checks,
    successful_checks,
    uptime_percentage
FROM ts.results_agg_1d
WHERE monitor_id = $1
AND bucket >= NOW() - INTERVAL '30 days'
ORDER BY bucket ASC
`

type GetUptimeTimeline30dRow struct {
	Bucket           interface{} `json:"bucket"`
	TotalChecks      int64       `json:"total_checks"`
	SuccessfulChecks int64       `json:"successful_checks"`
	UptimePercentage int32       `json:"uptime_percentage"`
}

func (q *Queries) GetUptimeTimeline30d(ctx context.Context, monitorID string) ([]*GetUptimeTimeline30dRow, error) {
	rows, err := q.db.QueryContext(ctx, getUptimeTimeline30d, monitorID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*GetUptimeTimeline30dRow
	for rows.Next() {
		var i GetUptimeTimeline30dRow
		if err := rows.Scan(
			&i.Bucket,
			&i.TotalChecks,
			&i.SuccessfulChecks,
			&i.UptimePercentage,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUptimeTimeline7d = `-- name: GetUptimeTimeline7d :many
SELECT 
    time_bucket(INTERVAL '2 hours', bucket) AS bucket,
    SUM(total_checks) as total_checks,
    SUM(successful_checks) as successful_checks,
    COALESCE(CAST(SUM(successful_checks) AS FLOAT) / NULLIF(SUM(total_checks), 0) * 100, 0)::int as uptime_percentage
FROM ts.results_agg_1h
WHERE monitor_id = $1
AND bucket >= NOW() - INTERVAL '7 days'
GROUP BY time_bucket(INTERVAL '2 hours', bucket)
ORDER BY bucket ASC
`

type GetUptimeTimeline7dRow struct {
	Bucket           interface{} `json:"bucket"`
	TotalChecks      int64       `json:"total_checks"`
	SuccessfulChecks int64       `json:"successful_checks"`
	UptimePercentage int32       `json:"uptime_percentage"`
}

func (q *Queries) GetUptimeTimeline7d(ctx context.Context, monitorID string) ([]*GetUptimeTimeline7dRow, error) {
	rows, err := q.db.QueryContext(ctx, getUptimeTimeline7d, monitorID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*GetUptimeTimeline7dRow
	for rows.Next() {
		var i GetUptimeTimeline7dRow
		if err := rows.Scan(
			&i.Bucket,
			&i.TotalChecks,
			&i.SuccessfulChecks,
			&i.UptimePercentage,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const upsertResult = `-- name: UpsertResult :one
INSERT INTO ts.results_raw (
    run_id, monitor_id, region, event_at, status,
    http_code, dns_ms, connect_ms, tls_ms, ttfb_ms,
    download_ms, total_ms, size_bytes, error_message
) VALUES (
    $1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14
)
ON CONFLICT (run_id, event_at) 
DO UPDATE SET
    status = EXCLUDED.status,
    http_code = EXCLUDED.http_code,
    dns_ms = EXCLUDED.dns_ms,
    connect_ms = EXCLUDED.connect_ms,
    tls_ms = EXCLUDED.tls_ms,
    ttfb_ms = EXCLUDED.ttfb_ms,
    download_ms = EXCLUDED.download_ms,
    total_ms = EXCLUDED.total_ms,
    size_bytes = EXCLUDED.size_bytes,
    error_message = EXCLUDED.error_message
RETURNING run_id, monitor_id, region, event_at, status, http_code, dns_ms, connect_ms, tls_ms, ttfb_ms, download_ms, total_ms, size_bytes, error_message
`

type UpsertResultParams struct {
	RunID        string         `json:"run_id"`
	MonitorID    string         `json:"monitor_id"`
	Region       string         `json:"region"`
	EventAt      time.Time      `json:"event_at"`
	Status       string         `json:"status"`
	HttpCode     sql.NullInt32  `json:"http_code"`
	DnsMs        sql.NullInt32  `json:"dns_ms"`
	ConnectMs    sql.NullInt32  `json:"connect_ms"`
	TlsMs        sql.NullInt32  `json:"tls_ms"`
	TtfbMs       sql.NullInt32  `json:"ttfb_ms"`
	DownloadMs   sql.NullInt32  `json:"download_ms"`
	TotalMs      sql.NullInt32  `json:"total_ms"`
	SizeBytes    sql.NullInt64  `json:"size_bytes"`
	ErrorMessage sql.NullString `json:"error_message"`
}

func (q *Queries) UpsertResult(ctx context.Context, arg *UpsertResultParams) (*TsResultsRaw, error) {
	row := q.db.QueryRowContext(ctx, upsertResult,
		arg.RunID,
		arg.MonitorID,
		arg.Region,
		arg.EventAt,
		arg.Status,
		arg.HttpCode,
		arg.DnsMs,
		arg.ConnectMs,
		arg.TlsMs,
		arg.TtfbMs,
		arg.DownloadMs,
		arg.TotalMs,
		arg.SizeBytes,
		arg.ErrorMessage,
	)
	var i TsResultsRaw
	err := row.Scan(
		&i.RunID,
		&i.MonitorID,
		&i.Region,
		&i.EventAt,
		&i.Status,
		&i.HttpCode,
		&i.DnsMs,
		&i.ConnectMs,
		&i.TlsMs,
		&i.TtfbMs,
		&i.DownloadMs,
		&i.TotalMs,
		&i.SizeBytes,
		&i.ErrorMessage,
	)
	return &i, err
}
