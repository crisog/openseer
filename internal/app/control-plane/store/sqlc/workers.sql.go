// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.26.0
// source: workers.sql

package sqlc

import (
	"context"
	"database/sql"
)

const addWorkerCapability = `-- name: AddWorkerCapability :exec
INSERT INTO app.worker_capabilities (worker_id, capability_key, capability_value)
VALUES ($1, $2, $3)
ON CONFLICT (worker_id, capability_key)
DO UPDATE SET capability_value = EXCLUDED.capability_value
`

type AddWorkerCapabilityParams struct {
	WorkerID        string `json:"worker_id"`
	CapabilityKey   string `json:"capability_key"`
	CapabilityValue string `json:"capability_value"`
}

func (q *Queries) AddWorkerCapability(ctx context.Context, arg *AddWorkerCapabilityParams) error {
	_, err := q.db.ExecContext(ctx, addWorkerCapability, arg.WorkerID, arg.CapabilityKey, arg.CapabilityValue)
	return err
}

const countWorkers = `-- name: CountWorkers :one
SELECT COUNT(*) FROM app.workers
WHERE ($1::TEXT IS NULL OR region = $1)
  AND ($2::TEXT IS NULL OR status = $2)
`

type CountWorkersParams struct {
	Column1 string `json:"column_1"`
	Column2 string `json:"column_2"`
}

func (q *Queries) CountWorkers(ctx context.Context, arg *CountWorkersParams) (int64, error) {
	row := q.db.QueryRowContext(ctx, countWorkers, arg.Column1, arg.Column2)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const deleteWorkerCapabilities = `-- name: DeleteWorkerCapabilities :exec
DELETE FROM app.worker_capabilities
WHERE worker_id = $1
`

func (q *Queries) DeleteWorkerCapabilities(ctx context.Context, workerID string) error {
	_, err := q.db.ExecContext(ctx, deleteWorkerCapabilities, workerID)
	return err
}

const enrollWorker = `-- name: EnrollWorker :one
INSERT INTO app.workers (
    id, hostname, region, version, 
    enrolled_at, last_seen_at, status, certificate_expires_at
) VALUES (
    $1, $2, $3, $4, NOW(), NOW(), 'enrolled', $5
)
RETURNING id, region, version, last_seen_at, registered_at, status, hostname, enrolled_at, certificate_expires_at, revoked_at, revoked_reason
`

type EnrollWorkerParams struct {
	ID                   string         `json:"id"`
	Hostname             sql.NullString `json:"hostname"`
	Region               string         `json:"region"`
	Version              string         `json:"version"`
	CertificateExpiresAt sql.NullTime   `json:"certificate_expires_at"`
}

func (q *Queries) EnrollWorker(ctx context.Context, arg *EnrollWorkerParams) (*AppWorker, error) {
	row := q.db.QueryRowContext(ctx, enrollWorker,
		arg.ID,
		arg.Hostname,
		arg.Region,
		arg.Version,
		arg.CertificateExpiresAt,
	)
	var i AppWorker
	err := row.Scan(
		&i.ID,
		&i.Region,
		&i.Version,
		&i.LastSeenAt,
		&i.RegisteredAt,
		&i.Status,
		&i.Hostname,
		&i.EnrolledAt,
		&i.CertificateExpiresAt,
		&i.RevokedAt,
		&i.RevokedReason,
	)
	return &i, err
}

const getActiveWorkers = `-- name: GetActiveWorkers :many
SELECT id, region, version, last_seen_at, registered_at, status, hostname, enrolled_at, certificate_expires_at, revoked_at, revoked_reason FROM app.workers
WHERE status = 'active'
AND last_seen_at >= NOW() - INTERVAL '1 minute'
ORDER BY region, id
`

func (q *Queries) GetActiveWorkers(ctx context.Context) ([]*AppWorker, error) {
	rows, err := q.db.QueryContext(ctx, getActiveWorkers)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*AppWorker
	for rows.Next() {
		var i AppWorker
		if err := rows.Scan(
			&i.ID,
			&i.Region,
			&i.Version,
			&i.LastSeenAt,
			&i.RegisteredAt,
			&i.Status,
			&i.Hostname,
			&i.EnrolledAt,
			&i.CertificateExpiresAt,
			&i.RevokedAt,
			&i.RevokedReason,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getWorkerByID = `-- name: GetWorkerByID :one
SELECT id, region, version, last_seen_at, registered_at, status, hostname, enrolled_at, certificate_expires_at, revoked_at, revoked_reason FROM app.workers
WHERE id = $1
`

func (q *Queries) GetWorkerByID(ctx context.Context, id string) (*AppWorker, error) {
	row := q.db.QueryRowContext(ctx, getWorkerByID, id)
	var i AppWorker
	err := row.Scan(
		&i.ID,
		&i.Region,
		&i.Version,
		&i.LastSeenAt,
		&i.RegisteredAt,
		&i.Status,
		&i.Hostname,
		&i.EnrolledAt,
		&i.CertificateExpiresAt,
		&i.RevokedAt,
		&i.RevokedReason,
	)
	return &i, err
}

const getWorkerCapabilities = `-- name: GetWorkerCapabilities :many
SELECT capability_key, capability_value
FROM app.worker_capabilities
WHERE worker_id = $1
`

type GetWorkerCapabilitiesRow struct {
	CapabilityKey   string `json:"capability_key"`
	CapabilityValue string `json:"capability_value"`
}

func (q *Queries) GetWorkerCapabilities(ctx context.Context, workerID string) ([]*GetWorkerCapabilitiesRow, error) {
	rows, err := q.db.QueryContext(ctx, getWorkerCapabilities, workerID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*GetWorkerCapabilitiesRow
	for rows.Next() {
		var i GetWorkerCapabilitiesRow
		if err := rows.Scan(&i.CapabilityKey, &i.CapabilityValue); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listRegionHealth = `-- name: ListRegionHealth :many
WITH region_stats AS (
    SELECT
        region,
        COUNT(*) FILTER (
            WHERE status = 'active'
              AND last_seen_at >= NOW() - INTERVAL '1 minute'
        ) AS healthy_workers
    FROM app.workers
    GROUP BY region
)
SELECT
    region,
    healthy_workers
FROM region_stats
ORDER BY region
`

type ListRegionHealthRow struct {
	Region         string `json:"region"`
	HealthyWorkers int64  `json:"healthy_workers"`
}

func (q *Queries) ListRegionHealth(ctx context.Context) ([]*ListRegionHealthRow, error) {
	rows, err := q.db.QueryContext(ctx, listRegionHealth)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*ListRegionHealthRow
	for rows.Next() {
		var i ListRegionHealthRow
		if err := rows.Scan(&i.Region, &i.HealthyWorkers); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listWorkers = `-- name: ListWorkers :many
SELECT id, region, version, last_seen_at, registered_at, status, hostname, enrolled_at, certificate_expires_at, revoked_at, revoked_reason FROM app.workers
WHERE ($1::TEXT IS NULL OR region = $1)
  AND ($2::TEXT IS NULL OR status = $2)
ORDER BY enrolled_at DESC
LIMIT $3 OFFSET $4
`

type ListWorkersParams struct {
	Column1 string `json:"column_1"`
	Column2 string `json:"column_2"`
	Limit   int32  `json:"limit"`
	Offset  int32  `json:"offset"`
}

func (q *Queries) ListWorkers(ctx context.Context, arg *ListWorkersParams) ([]*AppWorker, error) {
	rows, err := q.db.QueryContext(ctx, listWorkers,
		arg.Column1,
		arg.Column2,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*AppWorker
	for rows.Next() {
		var i AppWorker
		if err := rows.Scan(
			&i.ID,
			&i.Region,
			&i.Version,
			&i.LastSeenAt,
			&i.RegisteredAt,
			&i.Status,
			&i.Hostname,
			&i.EnrolledAt,
			&i.CertificateExpiresAt,
			&i.RevokedAt,
			&i.RevokedReason,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const markWorkerInactive = `-- name: MarkWorkerInactive :exec
UPDATE app.workers
SET status = 'inactive'
WHERE status IN ('active', 'enrolled')
  AND last_seen_at < NOW() - INTERVAL '2 minutes'
`

func (q *Queries) MarkWorkerInactive(ctx context.Context) error {
	_, err := q.db.ExecContext(ctx, markWorkerInactive)
	return err
}

const registerWorker = `-- name: RegisterWorker :one
INSERT INTO app.workers (
    id, region, version, last_seen_at, status
) VALUES (
    $1, $2, $3, NOW(), 'active'
)
ON CONFLICT (id)
DO UPDATE SET
    last_seen_at = NOW(),
    status = 'active'
RETURNING id, region, version, last_seen_at, registered_at, status, hostname, enrolled_at, certificate_expires_at, revoked_at, revoked_reason
`

type RegisterWorkerParams struct {
	ID      string `json:"id"`
	Region  string `json:"region"`
	Version string `json:"version"`
}

func (q *Queries) RegisterWorker(ctx context.Context, arg *RegisterWorkerParams) (*AppWorker, error) {
	row := q.db.QueryRowContext(ctx, registerWorker, arg.ID, arg.Region, arg.Version)
	var i AppWorker
	err := row.Scan(
		&i.ID,
		&i.Region,
		&i.Version,
		&i.LastSeenAt,
		&i.RegisteredAt,
		&i.Status,
		&i.Hostname,
		&i.EnrolledAt,
		&i.CertificateExpiresAt,
		&i.RevokedAt,
		&i.RevokedReason,
	)
	return &i, err
}

const renewWorkerCertificate = `-- name: RenewWorkerCertificate :one
UPDATE app.workers
SET certificate_expires_at = $1, last_seen_at = NOW()
WHERE id = $2
RETURNING id, region, version, last_seen_at, registered_at, status, hostname, enrolled_at, certificate_expires_at, revoked_at, revoked_reason
`

type RenewWorkerCertificateParams struct {
	CertificateExpiresAt sql.NullTime `json:"certificate_expires_at"`
	ID                   string       `json:"id"`
}

func (q *Queries) RenewWorkerCertificate(ctx context.Context, arg *RenewWorkerCertificateParams) (*AppWorker, error) {
	row := q.db.QueryRowContext(ctx, renewWorkerCertificate, arg.CertificateExpiresAt, arg.ID)
	var i AppWorker
	err := row.Scan(
		&i.ID,
		&i.Region,
		&i.Version,
		&i.LastSeenAt,
		&i.RegisteredAt,
		&i.Status,
		&i.Hostname,
		&i.EnrolledAt,
		&i.CertificateExpiresAt,
		&i.RevokedAt,
		&i.RevokedReason,
	)
	return &i, err
}

const revokeWorker = `-- name: RevokeWorker :exec
UPDATE app.workers
SET status = 'revoked', revoked_at = NOW(), revoked_reason = $1
WHERE id = $2
`

type RevokeWorkerParams struct {
	RevokedReason sql.NullString `json:"revoked_reason"`
	ID            string         `json:"id"`
}

func (q *Queries) RevokeWorker(ctx context.Context, arg *RevokeWorkerParams) error {
	_, err := q.db.ExecContext(ctx, revokeWorker, arg.RevokedReason, arg.ID)
	return err
}

const updateWorkerHeartbeat = `-- name: UpdateWorkerHeartbeat :exec
UPDATE app.workers
SET last_seen_at = NOW()
WHERE id = $1
`

func (q *Queries) UpdateWorkerHeartbeat(ctx context.Context, id string) error {
	_, err := q.db.ExecContext(ctx, updateWorkerHeartbeat, id)
	return err
}
