// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: monitors.sql

package sqlc

import (
	"context"
	"database/sql"

	"github.com/lib/pq"
	"github.com/sqlc-dev/pqtype"
)

const countActiveMonitorsByID = `-- name: CountActiveMonitorsByID :one
SELECT COUNT(*)
FROM app.active_monitors
WHERE id = $1
`

func (q *Queries) CountActiveMonitorsByID(ctx context.Context, id string) (int64, error) {
	row := q.db.QueryRowContext(ctx, countActiveMonitorsByID, id)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createMonitor = `-- name: CreateMonitor :one
INSERT INTO app.monitors (
    id, name, url, interval_ms, timeout_ms, regions,
    jitter_seed, rate_limit_key, method, headers, assertions, enabled, user_id
) VALUES (
    $1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13
)
RETURNING id, url, interval_ms, timeout_ms, regions, jitter_seed, rate_limit_key, method, headers, assertions, enabled, last_scheduled_at, next_due_at, user_id, created_at, updated_at, name, deleted_at
`

type CreateMonitorParams struct {
	ID           string                `json:"id"`
	Name         string                `json:"name"`
	Url          string                `json:"url"`
	IntervalMs   int32                 `json:"interval_ms"`
	TimeoutMs    int32                 `json:"timeout_ms"`
	Regions      []string              `json:"regions"`
	JitterSeed   int32                 `json:"jitter_seed"`
	RateLimitKey sql.NullString        `json:"rate_limit_key"`
	Method       string                `json:"method"`
	Headers      pqtype.NullRawMessage `json:"headers"`
	Assertions   pqtype.NullRawMessage `json:"assertions"`
	Enabled      sql.NullBool          `json:"enabled"`
	UserID       sql.NullString        `json:"user_id"`
}

func (q *Queries) CreateMonitor(ctx context.Context, arg *CreateMonitorParams) (*AppMonitor, error) {
	row := q.db.QueryRowContext(ctx, createMonitor,
		arg.ID,
		arg.Name,
		arg.Url,
		arg.IntervalMs,
		arg.TimeoutMs,
		pq.Array(arg.Regions),
		arg.JitterSeed,
		arg.RateLimitKey,
		arg.Method,
		arg.Headers,
		arg.Assertions,
		arg.Enabled,
		arg.UserID,
	)
	var i AppMonitor
	err := row.Scan(
		&i.ID,
		&i.Url,
		&i.IntervalMs,
		&i.TimeoutMs,
		pq.Array(&i.Regions),
		&i.JitterSeed,
		&i.RateLimitKey,
		&i.Method,
		&i.Headers,
		&i.Assertions,
		&i.Enabled,
		&i.LastScheduledAt,
		&i.NextDueAt,
		&i.UserID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Name,
		&i.DeletedAt,
	)
	return &i, err
}

const deleteMonitor = `-- name: DeleteMonitor :exec
UPDATE app.monitors
SET deleted_at = NOW()
WHERE id = $1 AND deleted_at IS NULL
`

func (q *Queries) DeleteMonitor(ctx context.Context, id string) error {
	_, err := q.db.ExecContext(ctx, deleteMonitor, id)
	return err
}

const deleteMonitorByUser = `-- name: DeleteMonitorByUser :exec
UPDATE app.monitors
SET deleted_at = NOW()
WHERE id = $1 AND user_id = $2 AND deleted_at IS NULL
`

type DeleteMonitorByUserParams struct {
	ID     string         `json:"id"`
	UserID sql.NullString `json:"user_id"`
}

func (q *Queries) DeleteMonitorByUser(ctx context.Context, arg *DeleteMonitorByUserParams) error {
	_, err := q.db.ExecContext(ctx, deleteMonitorByUser, arg.ID, arg.UserID)
	return err
}

const deleteMonitorJobs = `-- name: DeleteMonitorJobs :exec
UPDATE app.jobs
SET deleted_at = NOW()
WHERE monitor_id = $1
AND status IN ('ready', 'leased')
AND deleted_at IS NULL
`

// Delete all pending jobs for a monitor (called when monitor is deleted)
func (q *Queries) DeleteMonitorJobs(ctx context.Context, monitorID string) error {
	_, err := q.db.ExecContext(ctx, deleteMonitorJobs, monitorID)
	return err
}

const getMonitor = `-- name: GetMonitor :one
SELECT id, url, interval_ms, timeout_ms, regions, jitter_seed, rate_limit_key, method, headers, assertions, enabled, last_scheduled_at, next_due_at, user_id, created_at, updated_at, name, deleted_at FROM app.monitors
WHERE id = $1 AND deleted_at IS NULL
`

func (q *Queries) GetMonitor(ctx context.Context, id string) (*AppMonitor, error) {
	row := q.db.QueryRowContext(ctx, getMonitor, id)
	var i AppMonitor
	err := row.Scan(
		&i.ID,
		&i.Url,
		&i.IntervalMs,
		&i.TimeoutMs,
		pq.Array(&i.Regions),
		&i.JitterSeed,
		&i.RateLimitKey,
		&i.Method,
		&i.Headers,
		&i.Assertions,
		&i.Enabled,
		&i.LastScheduledAt,
		&i.NextDueAt,
		&i.UserID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Name,
		&i.DeletedAt,
	)
	return &i, err
}

const getMonitorByUser = `-- name: GetMonitorByUser :one
SELECT id, url, interval_ms, timeout_ms, regions, jitter_seed, rate_limit_key, method, headers, assertions, enabled, last_scheduled_at, next_due_at, user_id, created_at, updated_at, name, deleted_at FROM app.monitors
WHERE id = $1 AND user_id = $2 AND deleted_at IS NULL
`

type GetMonitorByUserParams struct {
	ID     string         `json:"id"`
	UserID sql.NullString `json:"user_id"`
}

func (q *Queries) GetMonitorByUser(ctx context.Context, arg *GetMonitorByUserParams) (*AppMonitor, error) {
	row := q.db.QueryRowContext(ctx, getMonitorByUser, arg.ID, arg.UserID)
	var i AppMonitor
	err := row.Scan(
		&i.ID,
		&i.Url,
		&i.IntervalMs,
		&i.TimeoutMs,
		pq.Array(&i.Regions),
		&i.JitterSeed,
		&i.RateLimitKey,
		&i.Method,
		&i.Headers,
		&i.Assertions,
		&i.Enabled,
		&i.LastScheduledAt,
		&i.NextDueAt,
		&i.UserID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Name,
		&i.DeletedAt,
	)
	return &i, err
}

const getMonitorIncludingDeleted = `-- name: GetMonitorIncludingDeleted :one
SELECT id, url, interval_ms, timeout_ms, regions, jitter_seed, rate_limit_key, method, headers, assertions, enabled, last_scheduled_at, next_due_at, user_id, created_at, updated_at, name, deleted_at FROM app.monitors
WHERE id = $1
LIMIT 1
`

func (q *Queries) GetMonitorIncludingDeleted(ctx context.Context, id string) (*AppMonitor, error) {
	row := q.db.QueryRowContext(ctx, getMonitorIncludingDeleted, id)
	var i AppMonitor
	err := row.Scan(
		&i.ID,
		&i.Url,
		&i.IntervalMs,
		&i.TimeoutMs,
		pq.Array(&i.Regions),
		&i.JitterSeed,
		&i.RateLimitKey,
		&i.Method,
		&i.Headers,
		&i.Assertions,
		&i.Enabled,
		&i.LastScheduledAt,
		&i.NextDueAt,
		&i.UserID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Name,
		&i.DeletedAt,
	)
	return &i, err
}

const listAllMonitors = `-- name: ListAllMonitors :many
SELECT id, url, interval_ms, timeout_ms, regions, jitter_seed, rate_limit_key, method, headers, assertions, enabled, last_scheduled_at, next_due_at, user_id, created_at, updated_at, name, deleted_at FROM app.monitors
WHERE deleted_at IS NULL
ORDER BY id
`

func (q *Queries) ListAllMonitors(ctx context.Context) ([]*AppMonitor, error) {
	rows, err := q.db.QueryContext(ctx, listAllMonitors)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*AppMonitor
	for rows.Next() {
		var i AppMonitor
		if err := rows.Scan(
			&i.ID,
			&i.Url,
			&i.IntervalMs,
			&i.TimeoutMs,
			pq.Array(&i.Regions),
			&i.JitterSeed,
			&i.RateLimitKey,
			&i.Method,
			&i.Headers,
			&i.Assertions,
			&i.Enabled,
			&i.LastScheduledAt,
			&i.NextDueAt,
			&i.UserID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Name,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listDueMonitors = `-- name: ListDueMonitors :many
SELECT id, url, interval_ms, timeout_ms, regions, jitter_seed, rate_limit_key, method, headers, assertions, enabled, last_scheduled_at, next_due_at, user_id, created_at, updated_at, name, deleted_at FROM app.monitors
WHERE enabled = true
  AND deleted_at IS NULL
  AND (next_due_at IS NULL OR next_due_at <= $1)
ORDER BY next_due_at NULLS FIRST
FOR UPDATE SKIP LOCKED
`

// List monitors that need jobs scheduled (look ahead by schedule window)
// Uses FOR UPDATE SKIP LOCKED to prevent race conditions between scheduler instances
func (q *Queries) ListDueMonitors(ctx context.Context, nextDueAt sql.NullTime) ([]*AppMonitor, error) {
	rows, err := q.db.QueryContext(ctx, listDueMonitors, nextDueAt)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*AppMonitor
	for rows.Next() {
		var i AppMonitor
		if err := rows.Scan(
			&i.ID,
			&i.Url,
			&i.IntervalMs,
			&i.TimeoutMs,
			pq.Array(&i.Regions),
			&i.JitterSeed,
			&i.RateLimitKey,
			&i.Method,
			&i.Headers,
			&i.Assertions,
			&i.Enabled,
			&i.LastScheduledAt,
			&i.NextDueAt,
			&i.UserID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Name,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listEnabledMonitors = `-- name: ListEnabledMonitors :many
SELECT id, url, interval_ms, timeout_ms, regions, jitter_seed, rate_limit_key, method, headers, assertions, enabled, last_scheduled_at, next_due_at, user_id, created_at, updated_at, name, deleted_at FROM app.monitors
WHERE enabled = true AND deleted_at IS NULL
ORDER BY id
`

func (q *Queries) ListEnabledMonitors(ctx context.Context) ([]*AppMonitor, error) {
	rows, err := q.db.QueryContext(ctx, listEnabledMonitors)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*AppMonitor
	for rows.Next() {
		var i AppMonitor
		if err := rows.Scan(
			&i.ID,
			&i.Url,
			&i.IntervalMs,
			&i.TimeoutMs,
			pq.Array(&i.Regions),
			&i.JitterSeed,
			&i.RateLimitKey,
			&i.Method,
			&i.Headers,
			&i.Assertions,
			&i.Enabled,
			&i.LastScheduledAt,
			&i.NextDueAt,
			&i.UserID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Name,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listEnabledMonitorsByUser = `-- name: ListEnabledMonitorsByUser :many
SELECT id, url, interval_ms, timeout_ms, regions, jitter_seed, rate_limit_key, method, headers, assertions, enabled, last_scheduled_at, next_due_at, user_id, created_at, updated_at, name, deleted_at FROM app.monitors
WHERE enabled = true AND user_id = $1 AND deleted_at IS NULL
ORDER BY created_at DESC
`

func (q *Queries) ListEnabledMonitorsByUser(ctx context.Context, userID sql.NullString) ([]*AppMonitor, error) {
	rows, err := q.db.QueryContext(ctx, listEnabledMonitorsByUser, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*AppMonitor
	for rows.Next() {
		var i AppMonitor
		if err := rows.Scan(
			&i.ID,
			&i.Url,
			&i.IntervalMs,
			&i.TimeoutMs,
			pq.Array(&i.Regions),
			&i.JitterSeed,
			&i.RateLimitKey,
			&i.Method,
			&i.Headers,
			&i.Assertions,
			&i.Enabled,
			&i.LastScheduledAt,
			&i.NextDueAt,
			&i.UserID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Name,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listMonitorsByUser = `-- name: ListMonitorsByUser :many
SELECT id, url, interval_ms, timeout_ms, regions, jitter_seed, rate_limit_key, method, headers, assertions, enabled, last_scheduled_at, next_due_at, user_id, created_at, updated_at, name, deleted_at FROM app.monitors
WHERE user_id = $1 AND deleted_at IS NULL
ORDER BY created_at DESC
`

func (q *Queries) ListMonitorsByUser(ctx context.Context, userID sql.NullString) ([]*AppMonitor, error) {
	rows, err := q.db.QueryContext(ctx, listMonitorsByUser, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*AppMonitor
	for rows.Next() {
		var i AppMonitor
		if err := rows.Scan(
			&i.ID,
			&i.Url,
			&i.IntervalMs,
			&i.TimeoutMs,
			pq.Array(&i.Regions),
			&i.JitterSeed,
			&i.RateLimitKey,
			&i.Method,
			&i.Headers,
			&i.Assertions,
			&i.Enabled,
			&i.LastScheduledAt,
			&i.NextDueAt,
			&i.UserID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Name,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateMonitor = `-- name: UpdateMonitor :one
UPDATE app.monitors SET
    name = $2,
    url = $3,
    interval_ms = $4,
    timeout_ms = $5,
    regions = $6,
    jitter_seed = $7,
    rate_limit_key = $8,
    method = $9,
    headers = $10,
    assertions = $11,
    enabled = $12,
    updated_at = NOW()
WHERE id = $1
RETURNING id, url, interval_ms, timeout_ms, regions, jitter_seed, rate_limit_key, method, headers, assertions, enabled, last_scheduled_at, next_due_at, user_id, created_at, updated_at, name, deleted_at
`

type UpdateMonitorParams struct {
	ID           string                `json:"id"`
	Name         string                `json:"name"`
	Url          string                `json:"url"`
	IntervalMs   int32                 `json:"interval_ms"`
	TimeoutMs    int32                 `json:"timeout_ms"`
	Regions      []string              `json:"regions"`
	JitterSeed   int32                 `json:"jitter_seed"`
	RateLimitKey sql.NullString        `json:"rate_limit_key"`
	Method       string                `json:"method"`
	Headers      pqtype.NullRawMessage `json:"headers"`
	Assertions   pqtype.NullRawMessage `json:"assertions"`
	Enabled      sql.NullBool          `json:"enabled"`
}

func (q *Queries) UpdateMonitor(ctx context.Context, arg *UpdateMonitorParams) (*AppMonitor, error) {
	row := q.db.QueryRowContext(ctx, updateMonitor,
		arg.ID,
		arg.Name,
		arg.Url,
		arg.IntervalMs,
		arg.TimeoutMs,
		pq.Array(arg.Regions),
		arg.JitterSeed,
		arg.RateLimitKey,
		arg.Method,
		arg.Headers,
		arg.Assertions,
		arg.Enabled,
	)
	var i AppMonitor
	err := row.Scan(
		&i.ID,
		&i.Url,
		&i.IntervalMs,
		&i.TimeoutMs,
		pq.Array(&i.Regions),
		&i.JitterSeed,
		&i.RateLimitKey,
		&i.Method,
		&i.Headers,
		&i.Assertions,
		&i.Enabled,
		&i.LastScheduledAt,
		&i.NextDueAt,
		&i.UserID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Name,
		&i.DeletedAt,
	)
	return &i, err
}

const updateMonitorByUser = `-- name: UpdateMonitorByUser :one
UPDATE app.monitors SET
    name = $3,
    url = $4,
    interval_ms = $5,
    timeout_ms = $6,
    regions = $7,
    jitter_seed = $8,
    rate_limit_key = $9,
    method = $10,
    headers = $11,
    assertions = $12,
    enabled = $13,
    updated_at = NOW()
WHERE id = $1 AND user_id = $2
RETURNING id, url, interval_ms, timeout_ms, regions, jitter_seed, rate_limit_key, method, headers, assertions, enabled, last_scheduled_at, next_due_at, user_id, created_at, updated_at, name, deleted_at
`

type UpdateMonitorByUserParams struct {
	ID           string                `json:"id"`
	UserID       sql.NullString        `json:"user_id"`
	Name         string                `json:"name"`
	Url          string                `json:"url"`
	IntervalMs   int32                 `json:"interval_ms"`
	TimeoutMs    int32                 `json:"timeout_ms"`
	Regions      []string              `json:"regions"`
	JitterSeed   int32                 `json:"jitter_seed"`
	RateLimitKey sql.NullString        `json:"rate_limit_key"`
	Method       string                `json:"method"`
	Headers      pqtype.NullRawMessage `json:"headers"`
	Assertions   pqtype.NullRawMessage `json:"assertions"`
	Enabled      sql.NullBool          `json:"enabled"`
}

func (q *Queries) UpdateMonitorByUser(ctx context.Context, arg *UpdateMonitorByUserParams) (*AppMonitor, error) {
	row := q.db.QueryRowContext(ctx, updateMonitorByUser,
		arg.ID,
		arg.UserID,
		arg.Name,
		arg.Url,
		arg.IntervalMs,
		arg.TimeoutMs,
		pq.Array(arg.Regions),
		arg.JitterSeed,
		arg.RateLimitKey,
		arg.Method,
		arg.Headers,
		arg.Assertions,
		arg.Enabled,
	)
	var i AppMonitor
	err := row.Scan(
		&i.ID,
		&i.Url,
		&i.IntervalMs,
		&i.TimeoutMs,
		pq.Array(&i.Regions),
		&i.JitterSeed,
		&i.RateLimitKey,
		&i.Method,
		&i.Headers,
		&i.Assertions,
		&i.Enabled,
		&i.LastScheduledAt,
		&i.NextDueAt,
		&i.UserID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Name,
		&i.DeletedAt,
	)
	return &i, err
}

const updateMonitorSchedulingTime = `-- name: UpdateMonitorSchedulingTime :one
UPDATE app.monitors SET
    last_scheduled_at = $2,
    next_due_at = $3,
    updated_at = NOW()
WHERE id = $1
RETURNING id, url, interval_ms, timeout_ms, regions, jitter_seed, rate_limit_key, method, headers, assertions, enabled, last_scheduled_at, next_due_at, user_id, created_at, updated_at, name, deleted_at
`

type UpdateMonitorSchedulingTimeParams struct {
	ID              string       `json:"id"`
	LastScheduledAt sql.NullTime `json:"last_scheduled_at"`
	NextDueAt       sql.NullTime `json:"next_due_at"`
}

func (q *Queries) UpdateMonitorSchedulingTime(ctx context.Context, arg *UpdateMonitorSchedulingTimeParams) (*AppMonitor, error) {
	row := q.db.QueryRowContext(ctx, updateMonitorSchedulingTime, arg.ID, arg.LastScheduledAt, arg.NextDueAt)
	var i AppMonitor
	err := row.Scan(
		&i.ID,
		&i.Url,
		&i.IntervalMs,
		&i.TimeoutMs,
		pq.Array(&i.Regions),
		&i.JitterSeed,
		&i.RateLimitKey,
		&i.Method,
		&i.Headers,
		&i.Assertions,
		&i.Enabled,
		&i.LastScheduledAt,
		&i.NextDueAt,
		&i.UserID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Name,
		&i.DeletedAt,
	)
	return &i, err
}
