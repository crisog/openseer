// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: jobs.sql

package sqlc

import (
	"context"
	"database/sql"
	"time"

	"github.com/lib/pq"
	"github.com/sqlc-dev/pqtype"
)

const checkJobExists = `-- name: CheckJobExists :one
SELECT EXISTS(
    SELECT 1 FROM app.jobs
    WHERE monitor_id = $1
    AND deleted_at IS NULL
    AND status IN ('ready', 'leased')
    AND scheduled_at BETWEEN $2 AND $3
) as exists
`

type CheckJobExistsParams struct {
	MonitorID     string    `json:"monitor_id"`
	ScheduledAt   time.Time `json:"scheduled_at"`
	ScheduledAt_2 time.Time `json:"scheduled_at_2"`
}

func (q *Queries) CheckJobExists(ctx context.Context, arg *CheckJobExistsParams) (bool, error) {
	row := q.db.QueryRowContext(ctx, checkJobExists, arg.MonitorID, arg.ScheduledAt, arg.ScheduledAt_2)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const completeJob = `-- name: CompleteJob :one
UPDATE app.jobs
SET status = 'done',
    lease_expires_at = NULL
WHERE run_id = $1
AND status = 'leased'
AND worker_id = $2
RETURNING run_id, monitor_id, region, status, scheduled_at, lease_expires_at, worker_id, created_at, deleted_at
`

type CompleteJobParams struct {
	RunID    string         `json:"run_id"`
	WorkerID sql.NullString `json:"worker_id"`
}

func (q *Queries) CompleteJob(ctx context.Context, arg *CompleteJobParams) (*AppJob, error) {
	row := q.db.QueryRowContext(ctx, completeJob, arg.RunID, arg.WorkerID)
	var i AppJob
	err := row.Scan(
		&i.RunID,
		&i.MonitorID,
		&i.Region,
		&i.Status,
		&i.ScheduledAt,
		&i.LeaseExpiresAt,
		&i.WorkerID,
		&i.CreatedAt,
		&i.DeletedAt,
	)
	return &i, err
}

const countDeletedJobsForMonitor = `-- name: CountDeletedJobsForMonitor :one
SELECT COUNT(*)
FROM app.jobs
WHERE monitor_id = $1
AND deleted_at IS NOT NULL
`

func (q *Queries) CountDeletedJobsForMonitor(ctx context.Context, monitorID string) (int64, error) {
	row := q.db.QueryRowContext(ctx, countDeletedJobsForMonitor, monitorID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countJobsForMonitor = `-- name: CountJobsForMonitor :one
SELECT COUNT(*) as count
FROM app.jobs
WHERE monitor_id = $1
AND deleted_at IS NULL
`

func (q *Queries) CountJobsForMonitor(ctx context.Context, monitorID string) (int64, error) {
	row := q.db.QueryRowContext(ctx, countJobsForMonitor, monitorID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createJob = `-- name: CreateJob :one
INSERT INTO app.jobs (
    run_id, monitor_id, region, status, scheduled_at
) VALUES (
    $1, $2, $3, 'ready', $4
)
RETURNING run_id, monitor_id, region, status, scheduled_at, lease_expires_at, worker_id, created_at, deleted_at
`

type CreateJobParams struct {
	RunID       string    `json:"run_id"`
	MonitorID   string    `json:"monitor_id"`
	Region      string    `json:"region"`
	ScheduledAt time.Time `json:"scheduled_at"`
}

func (q *Queries) CreateJob(ctx context.Context, arg *CreateJobParams) (*AppJob, error) {
	row := q.db.QueryRowContext(ctx, createJob,
		arg.RunID,
		arg.MonitorID,
		arg.Region,
		arg.ScheduledAt,
	)
	var i AppJob
	err := row.Scan(
		&i.RunID,
		&i.MonitorID,
		&i.Region,
		&i.Status,
		&i.ScheduledAt,
		&i.LeaseExpiresAt,
		&i.WorkerID,
		&i.CreatedAt,
		&i.DeletedAt,
	)
	return &i, err
}

const createJobIdempotent = `-- name: CreateJobIdempotent :one
INSERT INTO app.jobs (
    run_id, monitor_id, region, status, scheduled_at
)
SELECT $1, $2, $3, 'ready', $4
WHERE NOT EXISTS (
    SELECT 1 FROM app.jobs j
    WHERE j.monitor_id = $2
    AND j.region = $3
    AND j.deleted_at IS NULL
    AND j.status IN ('ready', 'leased')
    AND j.scheduled_at BETWEEN $5 AND $6  -- Time window parameters
)
RETURNING run_id, monitor_id, region, status, scheduled_at, lease_expires_at, worker_id, created_at, deleted_at
`

type CreateJobIdempotentParams struct {
	RunID         string    `json:"run_id"`
	MonitorID     string    `json:"monitor_id"`
	Region        string    `json:"region"`
	ScheduledAt   time.Time `json:"scheduled_at"`
	ScheduledAt_2 time.Time `json:"scheduled_at_2"`
	ScheduledAt_3 time.Time `json:"scheduled_at_3"`
}

func (q *Queries) CreateJobIdempotent(ctx context.Context, arg *CreateJobIdempotentParams) (*AppJob, error) {
	row := q.db.QueryRowContext(ctx, createJobIdempotent,
		arg.RunID,
		arg.MonitorID,
		arg.Region,
		arg.ScheduledAt,
		arg.ScheduledAt_2,
		arg.ScheduledAt_3,
	)
	var i AppJob
	err := row.Scan(
		&i.RunID,
		&i.MonitorID,
		&i.Region,
		&i.Status,
		&i.ScheduledAt,
		&i.LeaseExpiresAt,
		&i.WorkerID,
		&i.CreatedAt,
		&i.DeletedAt,
	)
	return &i, err
}

const forceExpireJobLease = `-- name: ForceExpireJobLease :exec
UPDATE app.jobs
SET lease_expires_at = $2
WHERE run_id = $1
`

type ForceExpireJobLeaseParams struct {
	RunID          string       `json:"run_id"`
	LeaseExpiresAt sql.NullTime `json:"lease_expires_at"`
}

func (q *Queries) ForceExpireJobLease(ctx context.Context, arg *ForceExpireJobLeaseParams) error {
	_, err := q.db.ExecContext(ctx, forceExpireJobLease, arg.RunID, arg.LeaseExpiresAt)
	return err
}

const getCompletedJobsByMonitor = `-- name: GetCompletedJobsByMonitor :many
SELECT run_id, monitor_id, region, status, scheduled_at, lease_expires_at, worker_id, created_at, deleted_at FROM app.jobs
WHERE monitor_id = $1
AND status = 'done'
AND deleted_at IS NULL
ORDER BY scheduled_at DESC
`

func (q *Queries) GetCompletedJobsByMonitor(ctx context.Context, monitorID string) ([]*AppJob, error) {
	rows, err := q.db.QueryContext(ctx, getCompletedJobsByMonitor, monitorID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*AppJob
	for rows.Next() {
		var i AppJob
		if err := rows.Scan(
			&i.RunID,
			&i.MonitorID,
			&i.Region,
			&i.Status,
			&i.ScheduledAt,
			&i.LeaseExpiresAt,
			&i.WorkerID,
			&i.CreatedAt,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getJobByRunID = `-- name: GetJobByRunID :one
SELECT run_id, monitor_id, region, status, scheduled_at, lease_expires_at, worker_id, created_at, deleted_at FROM app.jobs
WHERE run_id = $1
LIMIT 1
`

func (q *Queries) GetJobByRunID(ctx context.Context, runID string) (*AppJob, error) {
	row := q.db.QueryRowContext(ctx, getJobByRunID, runID)
	var i AppJob
	err := row.Scan(
		&i.RunID,
		&i.MonitorID,
		&i.Region,
		&i.Status,
		&i.ScheduledAt,
		&i.LeaseExpiresAt,
		&i.WorkerID,
		&i.CreatedAt,
		&i.DeletedAt,
	)
	return &i, err
}

const getJobsForMonitor = `-- name: GetJobsForMonitor :many
SELECT run_id, monitor_id, region, status, scheduled_at, lease_expires_at, worker_id, created_at, deleted_at FROM app.jobs
WHERE monitor_id = $1
AND deleted_at IS NULL
ORDER BY scheduled_at DESC
`

func (q *Queries) GetJobsForMonitor(ctx context.Context, monitorID string) ([]*AppJob, error) {
	rows, err := q.db.QueryContext(ctx, getJobsForMonitor, monitorID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*AppJob
	for rows.Next() {
		var i AppJob
		if err := rows.Scan(
			&i.RunID,
			&i.MonitorID,
			&i.Region,
			&i.Status,
			&i.ScheduledAt,
			&i.LeaseExpiresAt,
			&i.WorkerID,
			&i.CreatedAt,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getReadyJobsCount = `-- name: GetReadyJobsCount :one
SELECT COUNT(*) as count
FROM app.jobs
WHERE status = 'ready'
AND deleted_at IS NULL
AND scheduled_at <= NOW()
`

func (q *Queries) GetReadyJobsCount(ctx context.Context) (int64, error) {
	row := q.db.QueryRowContext(ctx, getReadyJobsCount)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const leaseJobs = `-- name: LeaseJobs :many
WITH leased_jobs AS (
    UPDATE app.jobs
    SET
        status = 'leased',
        lease_expires_at = NOW() + INTERVAL '45 seconds',
        worker_id = $1
    WHERE run_id IN (
        SELECT run_id
        FROM app.jobs
        WHERE status = 'ready'
        AND deleted_at IS NULL
        AND scheduled_at <= NOW()
        AND app.jobs.region = $3  -- Filter by worker region
        ORDER BY scheduled_at
        LIMIT $2
        FOR UPDATE SKIP LOCKED
    )
    RETURNING run_id, monitor_id, region, status, scheduled_at, lease_expires_at, worker_id, created_at, deleted_at
)
SELECT run_id, monitor_id, region, status, scheduled_at, lease_expires_at, worker_id, created_at, deleted_at FROM leased_jobs
`

type LeaseJobsParams struct {
	WorkerID sql.NullString `json:"worker_id"`
	Limit    int32          `json:"limit"`
	Region   string         `json:"region"`
}

type LeaseJobsRow struct {
	RunID          string         `json:"run_id"`
	MonitorID      string         `json:"monitor_id"`
	Region         string         `json:"region"`
	Status         string         `json:"status"`
	ScheduledAt    time.Time      `json:"scheduled_at"`
	LeaseExpiresAt sql.NullTime   `json:"lease_expires_at"`
	WorkerID       sql.NullString `json:"worker_id"`
	CreatedAt      time.Time      `json:"created_at"`
	DeletedAt      sql.NullTime   `json:"deleted_at"`
}

func (q *Queries) LeaseJobs(ctx context.Context, arg *LeaseJobsParams) ([]*LeaseJobsRow, error) {
	rows, err := q.db.QueryContext(ctx, leaseJobs, arg.WorkerID, arg.Limit, arg.Region)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*LeaseJobsRow
	for rows.Next() {
		var i LeaseJobsRow
		if err := rows.Scan(
			&i.RunID,
			&i.MonitorID,
			&i.Region,
			&i.Status,
			&i.ScheduledAt,
			&i.LeaseExpiresAt,
			&i.WorkerID,
			&i.CreatedAt,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const leaseJobsWithFallback = `-- name: LeaseJobsWithFallback :many
WITH leased_jobs AS (
    UPDATE app.jobs
    SET
        status = 'leased',
        lease_expires_at = NOW() + INTERVAL '45 seconds',
        worker_id = $1
    WHERE run_id IN (
        SELECT run_id
        FROM app.jobs
        WHERE status = 'ready'
        AND deleted_at IS NULL
        AND scheduled_at <= NOW()
        AND app.jobs.region IN ($3, 'global')  -- Try worker region first, then global
        ORDER BY
            CASE WHEN app.jobs.region = $3 THEN 0 ELSE 1 END,  -- Prioritize exact region match
            scheduled_at
        LIMIT $2
        FOR UPDATE SKIP LOCKED
    )
    RETURNING run_id, monitor_id, region, status, scheduled_at, lease_expires_at, worker_id, created_at, deleted_at
)
SELECT run_id, monitor_id, region, status, scheduled_at, lease_expires_at, worker_id, created_at, deleted_at FROM leased_jobs
`

type LeaseJobsWithFallbackParams struct {
	WorkerID sql.NullString `json:"worker_id"`
	Limit    int32          `json:"limit"`
	Region   string         `json:"region"`
}

type LeaseJobsWithFallbackRow struct {
	RunID          string         `json:"run_id"`
	MonitorID      string         `json:"monitor_id"`
	Region         string         `json:"region"`
	Status         string         `json:"status"`
	ScheduledAt    time.Time      `json:"scheduled_at"`
	LeaseExpiresAt sql.NullTime   `json:"lease_expires_at"`
	WorkerID       sql.NullString `json:"worker_id"`
	CreatedAt      time.Time      `json:"created_at"`
	DeletedAt      sql.NullTime   `json:"deleted_at"`
}

func (q *Queries) LeaseJobsWithFallback(ctx context.Context, arg *LeaseJobsWithFallbackParams) ([]*LeaseJobsWithFallbackRow, error) {
	rows, err := q.db.QueryContext(ctx, leaseJobsWithFallback, arg.WorkerID, arg.Limit, arg.Region)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*LeaseJobsWithFallbackRow
	for rows.Next() {
		var i LeaseJobsWithFallbackRow
		if err := rows.Scan(
			&i.RunID,
			&i.MonitorID,
			&i.Region,
			&i.Status,
			&i.ScheduledAt,
			&i.LeaseExpiresAt,
			&i.WorkerID,
			&i.CreatedAt,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const leaseJobsWithMonitorData = `-- name: LeaseJobsWithMonitorData :many
WITH leased_jobs AS (
    UPDATE app.jobs
    SET
        status = 'leased',
        lease_expires_at = NOW() + INTERVAL '45 seconds',
        worker_id = $1
    WHERE run_id IN (
        SELECT run_id
        FROM app.jobs
        WHERE status = 'ready'
        AND deleted_at IS NULL
        AND scheduled_at <= NOW()
        AND app.jobs.region IN ($3, 'global')  -- Try worker region first, then global
        ORDER BY
            CASE WHEN app.jobs.region = $3 THEN 0 ELSE 1 END,  -- Prioritize exact region match
            scheduled_at
        LIMIT $2
        FOR UPDATE SKIP LOCKED
    )
    RETURNING run_id, monitor_id, region, status, scheduled_at, lease_expires_at, worker_id, created_at, deleted_at
)
SELECT
    j.run_id,
    j.monitor_id,
    j.region,
    j.status,
    j.scheduled_at,
    j.lease_expires_at,
    j.worker_id,
    j.created_at,
    j.deleted_at,
    m.id as monitor_id_2,
    m.url,
    m.method,
    m.timeout_ms,
    m.interval_ms,
    m.headers,
    m.regions
FROM leased_jobs j
JOIN app.monitors m ON j.monitor_id = m.id
WHERE m.deleted_at IS NULL
`

type LeaseJobsWithMonitorDataParams struct {
	WorkerID sql.NullString `json:"worker_id"`
	Limit    int32          `json:"limit"`
	Region   string         `json:"region"`
}

type LeaseJobsWithMonitorDataRow struct {
	RunID          string                `json:"run_id"`
	MonitorID      string                `json:"monitor_id"`
	Region         string                `json:"region"`
	Status         string                `json:"status"`
	ScheduledAt    time.Time             `json:"scheduled_at"`
	LeaseExpiresAt sql.NullTime          `json:"lease_expires_at"`
	WorkerID       sql.NullString        `json:"worker_id"`
	CreatedAt      time.Time             `json:"created_at"`
	DeletedAt      sql.NullTime          `json:"deleted_at"`
	MonitorID2     string                `json:"monitor_id_2"`
	Url            string                `json:"url"`
	Method         string                `json:"method"`
	TimeoutMs      int32                 `json:"timeout_ms"`
	IntervalMs     int32                 `json:"interval_ms"`
	Headers        pqtype.NullRawMessage `json:"headers"`
	Regions        []string              `json:"regions"`
}

// Lease jobs with monitor data
func (q *Queries) LeaseJobsWithMonitorData(ctx context.Context, arg *LeaseJobsWithMonitorDataParams) ([]*LeaseJobsWithMonitorDataRow, error) {
	rows, err := q.db.QueryContext(ctx, leaseJobsWithMonitorData, arg.WorkerID, arg.Limit, arg.Region)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*LeaseJobsWithMonitorDataRow
	for rows.Next() {
		var i LeaseJobsWithMonitorDataRow
		if err := rows.Scan(
			&i.RunID,
			&i.MonitorID,
			&i.Region,
			&i.Status,
			&i.ScheduledAt,
			&i.LeaseExpiresAt,
			&i.WorkerID,
			&i.CreatedAt,
			&i.DeletedAt,
			&i.MonitorID2,
			&i.Url,
			&i.Method,
			&i.TimeoutMs,
			&i.IntervalMs,
			&i.Headers,
			pq.Array(&i.Regions),
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const reclaimExpiredLeases = `-- name: ReclaimExpiredLeases :exec
UPDATE app.jobs
SET 
    status = 'ready',
    lease_expires_at = NULL,
    worker_id = NULL
WHERE status = 'leased'
AND deleted_at IS NULL
AND lease_expires_at < NOW()
`

func (q *Queries) ReclaimExpiredLeases(ctx context.Context) error {
	_, err := q.db.ExecContext(ctx, reclaimExpiredLeases)
	return err
}

const renewLease = `-- name: RenewLease :one
UPDATE app.jobs
SET lease_expires_at = NOW() + INTERVAL '45 seconds'
WHERE run_id = $1 
AND status = 'leased'
AND worker_id = $2
RETURNING run_id, monitor_id, region, status, scheduled_at, lease_expires_at, worker_id, created_at, deleted_at
`

type RenewLeaseParams struct {
	RunID    string         `json:"run_id"`
	WorkerID sql.NullString `json:"worker_id"`
}

func (q *Queries) RenewLease(ctx context.Context, arg *RenewLeaseParams) (*AppJob, error) {
	row := q.db.QueryRowContext(ctx, renewLease, arg.RunID, arg.WorkerID)
	var i AppJob
	err := row.Scan(
		&i.RunID,
		&i.MonitorID,
		&i.Region,
		&i.Status,
		&i.ScheduledAt,
		&i.LeaseExpiresAt,
		&i.WorkerID,
		&i.CreatedAt,
		&i.DeletedAt,
	)
	return &i, err
}
